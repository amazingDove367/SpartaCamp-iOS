<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Diffs</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>var numbers: [Int] = []
numbers.append(1)
numbers.append(2)
numbers.append(3)

numbers.insert(7, at: 1)

print(numbers)

numbers.remove(at: 1)

print(numbers)

print(numbers.capacity)
print(numbers.count)

numbers.append(33)

print(numbers.capacity)
print(numbers.count)

let desc = numbers.description
print(desc)
print(numbers)
print(numbers.endIndex)
print(numbers.startIndex)
print(numbers.isEmpty)


var dic: [String: Int] = ["Hakyung" : 1]
print(dic)
print(dic["Hakyung"])

dic["jan"] = 1
print(dic["1"])

print(dic.removeValue(forKey: "jen"))

print(dic.removeValue(forKey: "jan"))
print(dic)



let languageCode = [
    "한국" : "kor",
    "미국" : "en",
    "일본" : "jp"
]

print(languageCode)

let code = languageCode["일본"]
print(code)


var exSet: Set = Set&lt;Int&gt;()
print(exSet)

exSet.insert(10)
print(exSet)

exSet.insert(20)
exSet.insert(30)
print(exSet)

print(exSet.remove(1))
print(exSet.remove(10))

print(exSet)

var exSet2 = Set&lt;Int&gt;([3,4,5,6,7])
print(exSet2)


// 축약형
var testARr = [Int]()
print(testARr)

var testArr2: [Int] = []
print(testArr2)

var tA4: Array&lt;Int&gt; = Array&lt;Int&gt;()
print(tA4)


//var dic1: Dictionary&lt;String, Int&gt; = Dictionary


// tuple
var phone = (os: "iOS", model: "iPhone13")
print(phone.0)
print(phone.os)


let str1 = "aaa"
let str2 = "aaa"
print(str1+str2)

let names1 = ["April", "Bob"]
let names2 = ["Chuck", "David"]
let names3 = names1 + names2
print(names3[2])

let score1 = 6
let score2 = 6

print(score1 &gt;= score2)


let num1 = 15
let num2 = 25
let sum = num1 + num2

if sum &gt; 10 {
    print("over 10")
} else {
    print("not over 10")
}

if num1 &gt; 19 &amp;&amp; num2 &gt; 19 {
    print("19세 이상 영화를 같이 볼 수 있네요")
}
if num1 &gt; 20 || num2 &gt; 20 {
    print("20세 이상 보호자가 있으면 놀이공원에 들어갈 수 있어요")
}


let result = num1 == num2 ? "same" : "not same"
print(result)


enum Direction {
    case up
    case down
    case left
    case right
}

let direction = Direction.down
switch direction {
case .up:
    print("up")
case .down:
    print("down")
case .left:
    print("left")
case .right:
    print("right")
}


func greeetings(friends: String, me: String = "Hakyung") {
    print("Hello, \(friends), i am \(me).")
}


greeetings(friends: "honey")


func sendMessage(from myName: String, to name: String) -&gt; String {
    return "Hello, \(name)! i am \(myName)"
}

print(sendMessage(from: "Hakyung", to: "Ken"))

func sendMess(_ name: String) -&gt; String {
    return "Hello, \(name)"
}
print(sendMess("손하경"))


// 가변 매개변수 (몇개의 변수가 들어올지 모를때)
// 가변 매개변수는 배열 []로 사용 가능
func sendMe(me: String, friends: String...) -&gt; String {
    return "Hello, \(friends), i am \(me)"
}

print(sendMe(me: "hakyung", friends: "jake", "ken", "ann"))




// conditional statement
let animal = "pig"

if animal == "dog" {
    print("강아지")
} else if animal == "cat" {
    print("고양이 사료주기")
} else {
    print("해당하는 동물 사료가 없습니다.")
}

// switch-cases
let color = "pink"

switch color {
case "blue":
    print("bvlue")
case "green":
    print("greeen")
case "pink":
    print("ppppink")
default:
    print("찾는 색 없음")
} 

let temperature = 39

switch temperature {
case -20...9:
    print("겨울")
case 10...14:
    print("가을")
case 15...25:
    print("봄")
case 26...35:
    print("여름")
default:
    print("이상기후")
}





// repetitive statement
for i in 1...4 {
    print("i: \(i)")
}

var number = 3
while number &lt; 5 {
    number += 1
}
print(number)


// repeat-while (== do-while)
var x = 6
repeat {
    x += 2
} while x &lt; 5

print("x: \(x)")




// optional
var name: String?
var optName: String? = "Hakyung"
print(optName)

//var requiredName: String = optName // error
//print(requiredName) // error


// optional binding
var n: Int? = nil
if var resule = n {
    print(result)
} else {
    print("optional binding fails")
}


// guard
var age: Int? = nil
age = 12
func printAge(age: Int?) {
    guard let unwrapped = age else {
        print("age is missing")
        return
    }
    print("age: \(unwrapped)")
}

printAge(age: age)



// typecasting
class Animal {}
class Cat: Animal {}
class Dog: Animal {
    func bark() {
        print("wal wal!!")
    }
}

let pets: [Animal] = [Cat(), Dog(), Cat(), Dog()]

for pet in pets {
    if let dog = pet as? Dog { // pet은 기본적으로 Animal 타입이지만, pet이 Dog 클래스로 변환이 가능한가? 를 물어볼때 'as?' 를 이용해서 typecasting 하는 것을 도와줌
        // as? 자체가 optional타입임!
        dog.bark()
    }
}


//let checking = { (id: String) in 
//    print("checking!!! id : \(id)")
//}
//
//checking("hortenssiaa")

// checking 이라는 input closure 체크 로직
// input closure : input을 받는 클로져
let checkingLogic = { (id: String) -&gt; Bool in 
    if id == "user000" {
        return false
    }
    return true
}

//let isValid = checking("user000")
////print(isValid)

// id와 checking 클로저를 매개변수로 받는 validate 함수 
func validate(id: String, checking: (String) -&gt; Bool) -&gt; Bool {
    print("Some Preperation work here...")
    let isValid = checking(id)
    return isValid
}

let validationResult = validate(id: "user000", checking: checkingLogic)
print("result: \(validationResult)")



// input없는 클로져
let printHello = { () -&gt; Void in
    print("Hello Swift")
}

func doSomeClosure(_ action: () -&gt; Void) {
    action() // action이라는 매개변수 자체가 클로저이기 때문에
}

doSomeClosure(printHello)





// 2
let validationResult2 = validate(id: "User001", checking: { (id: String) -&gt; Bool in 
    if id == "User000" {
        return false
    }
    return true
})


doSomeClosure({
    print("nonamed closure")
})

validate(id: "User001", checking: { (id: String) -&gt; Bool in
    if id == "User000" {
        return false
    }
    return true
})

doSomeClosure({
    print("...이렇게!!")
})



let validationResult3 = validate(id: "User001", checking: { id in
    let isValid = id != "User000"
    return isValid
})
print("validationResult3: \(validationResult3)")


// $0 : closure로 들어오는 input &amp; return 도 생략 가능
let validateResult4 = validate(id: "User000", checking: { $0 != "User000" })
print("validationResult4: \(validateResult4)")

// 트레일링 trailing closure. 마지막에 들어오는 파마매터의 클로저는, 파라메터의 이름을 생략할 수 있다.  
// 협업자가 못알아볼 수 있기 때문에, 상황에 맞게 사용
let validateResult5 = validate(id: "User001") {$0 != "User000"}
print("validateResult5 : \(validateResult5)")
</string>
			<key>ModifiedRange</key>
			<string>{1, 6129}</string>
			<key>OriginalContent</key>
			<string></string>
			<key>OriginalRange</key>
			<string>{1, 0}</string>
		</dict>
	</array>
	<key>FormatVersion</key>
	<integer>2</integer>
</dict>
</plist>
